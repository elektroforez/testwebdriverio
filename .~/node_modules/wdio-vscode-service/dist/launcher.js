import fs from 'node:fs/promises';
import path from 'node:path';
import { format } from 'node:util';
import downloadBundle from '@xhmikosr/downloader';
import logger from '@wdio/logger';
import { setGlobalDispatcher, request, ProxyAgent } from 'undici';
import { download } from '@vscode/test-electron';
import { SevereServiceError } from 'webdriverio';
import { HttpsProxyAgent } from 'hpagent';
import startServer from './server/index.js';
import { fileExist, directoryExists } from './utils.js';
import { DEFAULT_CHANNEL, VSCODE_RELEASES, VSCODE_MANIFEST_URL, DEFAULT_CACHE_PATH, VSCODE_CAPABILITY_KEY, VSCODE_WEB_STANDALONE, DEFAULT_VSCODE_WEB_HOSTNAME } from './constants.js';
// set up proxy if environment variable HTTPS_PROXY or https_proxy is set
let downloadAgentConfiguration;
const httpsProxy = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.npm_config_proxy;
if (httpsProxy) {
    const proxyUrl = new URL(httpsProxy);
    const token = proxyUrl.username && proxyUrl.password
        ? `Basic ${btoa(`${proxyUrl.username}:${proxyUrl.password}`)}`
        : undefined;
    setGlobalDispatcher(new ProxyAgent({ uri: proxyUrl.protocol + proxyUrl.host, token }));
    // @ts-expect-error downloadAgentConfiguration is not part of the official API
    downloadAgentConfiguration = { agent: new HttpsProxyAgent({ proxy: proxyUrl }) };
}
// use HTTPS_PROXY or https_proxy for @vscode/test-electron if not already set
if (httpsProxy !== process.env.npm_config_proxy) {
    process.env.npm_config_proxy = httpsProxy;
}
const VERSIONS_TXT = 'versions.txt';
const log = logger('wdio-vscode-service/launcher');
export default class VSCodeServiceLauncher {
    constructor(_options) {
        this._options = _options;
        this._cachePath = this._options.cachePath || DEFAULT_CACHE_PATH;
    }
    async onPrepare(_, capabilities) {
        const caps = Array.isArray(capabilities)
            ? capabilities.map((c) => (c.alwaysMatch || c))
            : Object.values(capabilities).map((c) => c.capabilities);
        /**
         * Check if we already have the VS Code bundle for the given version
         * and continue without download if possible
         */
        const versionsFilePath = path.join(this._cachePath, VERSIONS_TXT);
        const versionsFileExist = await fileExist(versionsFilePath);
        for (const cap of caps) {
            /**
             * skip setup if user is not using VSCode as capability
             */
            if (typeof cap.browserName !== 'string' || !cap[VSCODE_CAPABILITY_KEY]) {
                continue;
            }
            const version = cap[VSCODE_CAPABILITY_KEY].version || cap.browserVersion || DEFAULT_CHANNEL;
            cap[VSCODE_CAPABILITY_KEY].version = version;
            /**
             * setup VSCode Desktop
             */
            if (cap.browserName === 'vscode') {
                await this._setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap);
                continue;
            }
            /**
             * setup VSCode Web
             */
            await this._setupVSCodeWeb(version, cap);
        }
    }
    /**
     * Set up VSCode for web testing
     * @param versionsFileExist true if we already have information stored about cached VSCode bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeWeb(version, cap) {
        /**
         * no need to do any work if we already started the server
         */
        if (this._vscodeServerPort || !cap[VSCODE_CAPABILITY_KEY]) {
            return;
        }
        try {
            const vscodeStandalone = await this._fetchVSCodeWebStandalone(version);
            const port = await startServer(vscodeStandalone, cap[VSCODE_CAPABILITY_KEY]);
            cap[VSCODE_CAPABILITY_KEY].serverOptions = {
                ...(cap[VSCODE_CAPABILITY_KEY].serverOptions || {
                    hostname: DEFAULT_VSCODE_WEB_HOSTNAME
                }),
                port
            };
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't start server for VSCode Web: ${err.message}`);
        }
    }
    /**
     * Set up VSCode for desktop testing
     * @param versionsFileExist true if we already have information stored about cached VSCode bundles
     * @param versionsFilePath string with path to cached directory
     * @param cap capabilities used for this test run
     */
    async _setupVSCodeDesktop(versionsFileExist, versionsFilePath, version, cap) {
        if (!cap[VSCODE_CAPABILITY_KEY]) {
            throw new Error(`No key "${VSCODE_CAPABILITY_KEY}" found in caps`);
        }
        if (versionsFileExist) {
            const content = JSON.parse((await fs.readFile(versionsFilePath, 'utf-8')).toString());
            const vscodeVersion = content[version]?.vscode;
            const chromedriverVersion = content[version]?.chromedriver;
            const vscodePath = cap[VSCODE_CAPABILITY_KEY]?.binary
                || path.join(this._cachePath, `vscode-${process.platform}-${process.arch}-${vscodeVersion}`);
            if (vscodeVersion && chromedriverVersion && await fileExist(vscodePath)) {
                log.info(`Skipping download, bundle for VSCode v${vscodeVersion} already exists`);
                cap.browserVersion = chromedriverVersion;
                cap[VSCODE_CAPABILITY_KEY].binary ||= await this._downloadVSCode(vscodeVersion);
                return;
            }
        }
        const vscodeVersion = await this._fetchVSCodeVersion(version);
        const chromedriverVersion = await this._fetchChromedriverVersion(vscodeVersion);
        cap.browserVersion = chromedriverVersion;
        cap[VSCODE_CAPABILITY_KEY].binary ||= await this._downloadVSCode(vscodeVersion);
        await this._updateVersionsTxt(version, vscodeVersion, chromedriverVersion, versionsFileExist);
    }
    /**
     * Download VSCode bundle
     * @param version VSCode version
     * @returns path to downloaded VSCode bundle
     */
    async _downloadVSCode(version) {
        try {
            log.info(`Download VSCode binary (${version})`);
            return await download({
                cachePath: this._cachePath,
                version
            });
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up VSCode: ${err.message}`);
        }
    }
    /**
     * Get VSCode version based on desired channel or validate version if provided
     * @param desiredReleaseChannel either release channel (e.g. "stable" or "insiders")
     *                              or a concrete version e.g. 1.66.0
     * @returns "main" if `desiredReleaseChannel` is "insiders" otherwise a concrete VSCode version
     */
    async _fetchVSCodeVersion(desiredReleaseChannel) {
        if (desiredReleaseChannel === 'insiders') {
            return 'main';
        }
        try {
            log.info(`Fetch releases from ${VSCODE_RELEASES}`);
            const { body: versions } = await request(VSCODE_RELEASES, {});
            const availableVersions = await versions.json();
            if (desiredReleaseChannel) {
                /**
                 * validate provided VSCode version
                 */
                const newDesiredReleaseChannel = desiredReleaseChannel === 'stable'
                    ? availableVersions[0]
                    : desiredReleaseChannel;
                if (!availableVersions.includes(newDesiredReleaseChannel)) {
                    throw new Error(`Desired version "${newDesiredReleaseChannel}" is not existent, available versions:`
                        + `${availableVersions.slice(0, 5).join(', ')}..., see ${VSCODE_RELEASES}`);
                }
                return newDesiredReleaseChannel;
            }
            return availableVersions[0];
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't fetch latest VSCode: ${err.message}`);
        }
    }
    /**
     * Fetches required Chromedriver version for given VSCode version
     * @param vscodeVersion branch or tag version of VSCode repository
     * @returns required Chromedriver version
     */
    async _fetchChromedriverVersion(vscodeVersion) {
        try {
            const { body } = await request(format(VSCODE_MANIFEST_URL, vscodeVersion), {});
            const manifest = await body.json();
            const chromium = manifest.registrations.find((r) => r.component.git.name === 'chromium');
            if (!chromium) {
                throw new Error('Can\'t find chromium version in manifest response');
            }
            return chromium.version.split('.')[0];
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't fetch Chromedriver version: ${err.message}`);
        }
    }
    /**
     * Fetches VSCode Web files
     * ToDo(Christian): allow to define a local VSCode development path
     *                  to be able to skip this part
     */
    async _fetchVSCodeWebStandalone(vscodeVersion) {
        if (vscodeVersion !== 'stable' && vscodeVersion !== 'insiders') {
            throw new Error('Running VSCode in the browser is only supported for "stable" and "insiders" version');
        }
        try {
            const { body } = await request(format(VSCODE_WEB_STANDALONE, vscodeVersion), {});
            const info = await body.json();
            const folder = path.join(this._cachePath, `vscode-web-${vscodeVersion}-${info.version}`);
            if (!(await directoryExists(folder))) {
                await downloadBundle(info.url, folder, { extract: true, strip: 1, ...downloadAgentConfiguration });
            }
            return { path: folder, vscodeVersion, version: info.version };
        }
        catch (err) {
            throw new SevereServiceError(`Couldn't set up VSCode Web: ${err.message}`);
        }
    }
    async _updateVersionsTxt(version, vscodeVersion, chromedriverVersion, versionsFileExist) {
        const newContent = {
            [version]: {
                chromedriver: chromedriverVersion,
                vscode: vscodeVersion
            }
        };
        const versionsTxtPath = path.join(this._cachePath, VERSIONS_TXT);
        if (!versionsFileExist) {
            return fs.writeFile(versionsTxtPath, JSON.stringify(newContent, null, 4), 'utf-8');
        }
        const content = JSON.parse((await fs.readFile(versionsTxtPath, 'utf-8')).toString());
        return fs.writeFile(versionsTxtPath, JSON.stringify({ ...content, ...newContent }, null, 4), 'utf-8');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF1bmNoZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvbGF1bmNoZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sa0JBQWtCLENBQUE7QUFDakMsT0FBTyxJQUFJLE1BQU0sV0FBVyxDQUFBO0FBQzVCLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxXQUFXLENBQUE7QUFFbEMsT0FBTyxjQUFtQyxNQUFNLHNCQUFzQixDQUFBO0FBQ3RFLE9BQU8sTUFBTSxNQUFNLGNBQWMsQ0FBQTtBQUNqQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLFFBQVEsQ0FBQTtBQUNqRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sdUJBQXVCLENBQUE7QUFDaEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sYUFBYSxDQUFBO0FBRWhELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxTQUFTLENBQUE7QUFFekMsT0FBTyxXQUFXLE1BQU0sbUJBQW1CLENBQUE7QUFDM0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQUUsTUFBTSxZQUFZLENBQUE7QUFDdkQsT0FBTyxFQUNILGVBQWUsRUFBRSxlQUFlLEVBQUUsbUJBQW1CLEVBQUUsa0JBQWtCLEVBQ3pFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFLDJCQUEyQixFQUM1RSxNQUFNLGdCQUFnQixDQUFBO0FBdUJ2Qix5RUFBeUU7QUFDekUsSUFBSSwwQkFBZ0UsQ0FBQTtBQUNwRSxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFBO0FBQ3JHLElBQUksVUFBVSxFQUFFLENBQUM7SUFDYixNQUFNLFFBQVEsR0FBRyxJQUFJLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQTtJQUNwQyxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsUUFBUSxJQUFJLFFBQVEsQ0FBQyxRQUFRO1FBQ2hELENBQUMsQ0FBQyxTQUFTLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxRQUFRLElBQUksUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUU7UUFDOUQsQ0FBQyxDQUFDLFNBQVMsQ0FBQTtJQUVmLG1CQUFtQixDQUFDLElBQUksVUFBVSxDQUFDLEVBQUUsR0FBRyxFQUFFLFFBQVEsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUE7SUFDdEYsOEVBQThFO0lBQzlFLDBCQUEwQixHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksZUFBZSxDQUFDLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQTtBQUNwRixDQUFDO0FBQ0QsOEVBQThFO0FBQzlFLElBQUksVUFBVSxLQUFLLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztJQUM5QyxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixHQUFHLFVBQVUsQ0FBQTtBQUM3QyxDQUFDO0FBRUQsTUFBTSxZQUFZLEdBQUcsY0FBYyxDQUFBO0FBQ25DLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyw4QkFBOEIsQ0FBQyxDQUFBO0FBQ2xELE1BQU0sQ0FBQyxPQUFPLE9BQU8scUJBQXFCO0lBSXRDLFlBQXFCLFFBQXdCO1FBQXhCLGFBQVEsR0FBUixRQUFRLENBQWdCO1FBQ3pDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLElBQUksa0JBQWtCLENBQUE7SUFDbkUsQ0FBQztJQUVELEtBQUssQ0FBQyxTQUFTLENBQUUsQ0FBUSxFQUFFLFlBQTZDO1FBQ3BFLE1BQU0sSUFBSSxHQUF5QixLQUFLLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQztZQUMxRCxDQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBRSxDQUFrQyxDQUFDLFdBQVcsSUFBSSxDQUFDLENBQXVCLENBQUM7WUFDdkcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBa0MsQ0FBQyxDQUFBO1FBRWxGOzs7V0FHRztRQUNILE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFBO1FBQ2pFLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxTQUFTLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtRQUUzRCxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ3JCOztlQUVHO1lBQ0gsSUFBSSxPQUFPLEdBQUcsQ0FBQyxXQUFXLEtBQUssUUFBUSxJQUFJLENBQUMsR0FBRyxDQUFDLHFCQUFxQixDQUFDLEVBQUUsQ0FBQztnQkFDckUsU0FBUTtZQUNaLENBQUM7WUFFRCxNQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQyxPQUFPLElBQUksR0FBRyxDQUFDLGNBQWMsSUFBSSxlQUFlLENBQUE7WUFDM0YsR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQTtZQUU1Qzs7ZUFFRztZQUNILElBQUksR0FBRyxDQUFDLFdBQVcsS0FBSyxRQUFRLEVBQUUsQ0FBQztnQkFDL0IsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUUsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFBO2dCQUNqRixTQUFRO1lBQ1osQ0FBQztZQUVEOztlQUVHO1lBQ0gsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQTtRQUM1QyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ssS0FBSyxDQUFDLGVBQWUsQ0FDekIsT0FBZSxFQUNmLEdBQXVCO1FBRXZCOztXQUVHO1FBQ0gsSUFBSSxJQUFJLENBQUMsaUJBQWlCLElBQUksQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsRUFBRSxDQUFDO1lBQ3hELE9BQU07UUFDVixDQUFDO1FBRUQsSUFBSSxDQUFDO1lBQ0QsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxPQUFPLENBQUMsQ0FBQTtZQUN0RSxNQUFNLElBQUksR0FBRyxNQUFNLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFBO1lBQzVFLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLGFBQWEsR0FBRztnQkFDdkMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLGFBQWEsSUFBSTtvQkFDNUMsUUFBUSxFQUFFLDJCQUEyQjtpQkFDeEMsQ0FBQztnQkFDRixJQUFJO2FBQ1AsQ0FBQTtRQUNMLENBQUM7UUFBQyxPQUFPLEdBQVEsRUFBRSxDQUFDO1lBQ2hCLE1BQU0sSUFBSSxrQkFBa0IsQ0FBQyx5Q0FBeUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUE7UUFDeEYsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLEtBQUssQ0FBQyxtQkFBbUIsQ0FDN0IsaUJBQTBCLEVBQzFCLGdCQUF3QixFQUN4QixPQUFlLEVBQ2YsR0FBdUI7UUFFdkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFLENBQUM7WUFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxXQUFXLHFCQUFxQixpQkFBaUIsQ0FBQyxDQUFBO1FBQ3RFLENBQUM7UUFFRCxJQUFJLGlCQUFpQixFQUFFLENBQUM7WUFDcEIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFhLENBQUE7WUFFakcsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLE1BQU0sQ0FBQTtZQUM5QyxNQUFNLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxZQUFZLENBQUE7WUFDMUQsTUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDLHFCQUFxQixDQUFDLEVBQUUsTUFBTTttQkFDOUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFVBQVUsT0FBTyxDQUFDLFFBQVEsSUFBSSxPQUFPLENBQUMsSUFBSSxJQUFJLGFBQWEsRUFBRSxDQUFDLENBQUE7WUFFaEcsSUFBSSxhQUFhLElBQUksbUJBQW1CLElBQUksTUFBTSxTQUFTLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQztnQkFDdEUsR0FBRyxDQUFDLElBQUksQ0FDSix5Q0FBeUMsYUFBYSxpQkFBaUIsQ0FDMUUsQ0FBQTtnQkFDRCxHQUFHLENBQUMsY0FBYyxHQUFHLG1CQUFtQixDQUFBO2dCQUN4QyxHQUFHLENBQUMscUJBQXFCLENBQUMsQ0FBQyxNQUFNLEtBQUssTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxDQUFBO2dCQUMvRSxPQUFNO1lBQ1YsQ0FBQztRQUNMLENBQUM7UUFFRCxNQUFNLGFBQWEsR0FBRyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQTtRQUM3RCxNQUFNLG1CQUFtQixHQUFHLE1BQU0sSUFBSSxDQUFDLHlCQUF5QixDQUFDLGFBQWEsQ0FBQyxDQUFBO1FBRS9FLEdBQUcsQ0FBQyxjQUFjLEdBQUcsbUJBQW1CLENBQUE7UUFDeEMsR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUMsTUFBTSxLQUFLLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQTtRQUMvRSxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixDQUFDLENBQUE7SUFDakcsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxLQUFLLENBQUMsZUFBZSxDQUFFLE9BQWU7UUFDMUMsSUFBSSxDQUFDO1lBQ0QsR0FBRyxDQUFDLElBQUksQ0FBQywyQkFBMkIsT0FBTyxHQUFHLENBQUMsQ0FBQTtZQUMvQyxPQUFPLE1BQU0sUUFBUSxDQUFDO2dCQUNsQixTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVU7Z0JBQzFCLE9BQU87YUFDVixDQUFDLENBQUE7UUFDTixDQUFDO1FBQUMsT0FBTyxHQUFRLEVBQUUsQ0FBQztZQUNoQixNQUFNLElBQUksa0JBQWtCLENBQUMsMkJBQTJCLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFBO1FBQzFFLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxLQUFLLENBQUMsbUJBQW1CLENBQUUscUJBQThCO1FBQzdELElBQUkscUJBQXFCLEtBQUssVUFBVSxFQUFFLENBQUM7WUFDdkMsT0FBTyxNQUFNLENBQUE7UUFDakIsQ0FBQztRQUVELElBQUksQ0FBQztZQUNELEdBQUcsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLGVBQWUsRUFBRSxDQUFDLENBQUE7WUFDbEQsTUFBTSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsR0FBRyxNQUFNLE9BQU8sQ0FBQyxlQUFlLEVBQUUsRUFBRSxDQUFDLENBQUE7WUFDN0QsTUFBTSxpQkFBaUIsR0FBYSxNQUFNLFFBQVEsQ0FBQyxJQUFJLEVBQWMsQ0FBQTtZQUVyRSxJQUFJLHFCQUFxQixFQUFFLENBQUM7Z0JBQ3hCOzttQkFFRztnQkFDSCxNQUFNLHdCQUF3QixHQUFHLHFCQUFxQixLQUFLLFFBQVE7b0JBQy9ELENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7b0JBQ3RCLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQTtnQkFDM0IsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLENBQUM7b0JBQ3hELE1BQU0sSUFBSSxLQUFLLENBQ1gsb0JBQW9CLHdCQUF3Qix3Q0FBd0M7MEJBQ2xGLEdBQUcsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksZUFBZSxFQUFFLENBQzdFLENBQUE7Z0JBQ0wsQ0FBQztnQkFFRCxPQUFPLHdCQUF3QixDQUFBO1lBQ25DLENBQUM7WUFFRCxPQUFPLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQy9CLENBQUM7UUFBQyxPQUFPLEdBQVEsRUFBRSxDQUFDO1lBQ2hCLE1BQU0sSUFBSSxrQkFBa0IsQ0FBQyxpQ0FBaUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUE7UUFDaEYsQ0FBQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssS0FBSyxDQUFDLHlCQUF5QixDQUFFLGFBQXFCO1FBQzFELElBQUksQ0FBQztZQUNELE1BQU0sRUFBRSxJQUFJLEVBQUUsR0FBRyxNQUFNLE9BQU8sQ0FBQyxNQUFNLENBQUMsbUJBQW1CLEVBQUUsYUFBYSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUE7WUFDOUUsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsSUFBSSxFQUFjLENBQUE7WUFDOUMsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksS0FBSyxVQUFVLENBQUMsQ0FBQTtZQUU3RixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ1osTUFBTSxJQUFJLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFBO1lBQ3hFLENBQUM7WUFFRCxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQ3pDLENBQUM7UUFBQyxPQUFPLEdBQVEsRUFBRSxDQUFDO1lBQ2hCLE1BQU0sSUFBSSxrQkFBa0IsQ0FBQyx3Q0FBd0MsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUE7UUFDdkYsQ0FBQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssS0FBSyxDQUFDLHlCQUF5QixDQUFFLGFBQXFCO1FBQzFELElBQUksYUFBYSxLQUFLLFFBQVEsSUFBSSxhQUFhLEtBQUssVUFBVSxFQUFFLENBQUM7WUFDN0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxxRkFBcUYsQ0FBQyxDQUFBO1FBQzFHLENBQUM7UUFFRCxJQUFJLENBQUM7WUFDRCxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsTUFBTSxPQUFPLENBQUMsTUFBTSxDQUFDLHFCQUFxQixFQUFFLGFBQWEsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBO1lBQ2hGLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksRUFBMkIsQ0FBQTtZQUN2RCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsY0FBYyxhQUFhLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUE7WUFFeEYsSUFBSSxDQUFDLENBQUMsTUFBTSxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUNuQyxNQUFNLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxHQUFHLDBCQUEwQixFQUFFLENBQUMsQ0FBQTtZQUN0RyxDQUFDO1lBRUQsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUE7UUFDakUsQ0FBQztRQUFDLE9BQU8sR0FBUSxFQUFFLENBQUM7WUFDaEIsTUFBTSxJQUFJLGtCQUFrQixDQUFDLCtCQUErQixHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQTtRQUM5RSxDQUFDO0lBQ0wsQ0FBQztJQUVPLEtBQUssQ0FBQyxrQkFBa0IsQ0FDNUIsT0FBZSxFQUNmLGFBQXFCLEVBQ3JCLG1CQUEyQixFQUMzQixpQkFBMEI7UUFFMUIsTUFBTSxVQUFVLEdBQWE7WUFDekIsQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDUCxZQUFZLEVBQUUsbUJBQW1CO2dCQUNqQyxNQUFNLEVBQUUsYUFBYTthQUN4QjtTQUNKLENBQUE7UUFDRCxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUE7UUFDaEUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFDckIsT0FBTyxFQUFFLENBQUMsU0FBUyxDQUNmLGVBQWUsRUFDZixJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQ25DLE9BQU8sQ0FDVixDQUFBO1FBQ0wsQ0FBQztRQUVELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQTtRQUNwRixPQUFPLEVBQUUsQ0FBQyxTQUFTLENBQ2YsZUFBZSxFQUNmLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLE9BQU8sRUFBRSxHQUFHLFVBQVUsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFDdEQsT0FBTyxDQUNWLENBQUE7SUFDTCxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnbm9kZTpmcy9wcm9taXNlcydcbmltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCdcbmltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ25vZGU6dXRpbCdcblxuaW1wb3J0IGRvd25sb2FkQnVuZGxlLCB7IERvd25sb2FkT3B0aW9ucyB9IGZyb20gJ0B4aG1pa29zci9kb3dubG9hZGVyJ1xuaW1wb3J0IGxvZ2dlciBmcm9tICdAd2Rpby9sb2dnZXInXG5pbXBvcnQgeyBzZXRHbG9iYWxEaXNwYXRjaGVyLCByZXF1ZXN0LCBQcm94eUFnZW50IH0gZnJvbSAndW5kaWNpJ1xuaW1wb3J0IHsgZG93bmxvYWQgfSBmcm9tICdAdnNjb2RlL3Rlc3QtZWxlY3Ryb24nXG5pbXBvcnQgeyBTZXZlcmVTZXJ2aWNlRXJyb3IgfSBmcm9tICd3ZWJkcml2ZXJpbydcbmltcG9ydCB0eXBlIHsgQ2FwYWJpbGl0aWVzIH0gZnJvbSAnQHdkaW8vdHlwZXMnXG5pbXBvcnQgeyBIdHRwc1Byb3h5QWdlbnQgfSBmcm9tICdocGFnZW50J1xuXG5pbXBvcnQgc3RhcnRTZXJ2ZXIgZnJvbSAnLi9zZXJ2ZXIvaW5kZXguanMnXG5pbXBvcnQgeyBmaWxlRXhpc3QsIGRpcmVjdG9yeUV4aXN0cyB9IGZyb20gJy4vdXRpbHMuanMnXG5pbXBvcnQge1xuICAgIERFRkFVTFRfQ0hBTk5FTCwgVlNDT0RFX1JFTEVBU0VTLCBWU0NPREVfTUFOSUZFU1RfVVJMLCBERUZBVUxUX0NBQ0hFX1BBVEgsXG4gICAgVlNDT0RFX0NBUEFCSUxJVFlfS0VZLCBWU0NPREVfV0VCX1NUQU5EQUxPTkUsIERFRkFVTFRfVlNDT0RFX1dFQl9IT1NUTkFNRVxufSBmcm9tICcuL2NvbnN0YW50cy5qcydcbmltcG9ydCB0eXBlIHtcbiAgICBTZXJ2aWNlT3B0aW9ucywgVlNDb2RlQ2FwYWJpbGl0aWVzLCBXZWJTdGFuZGFsb25lUmVzcG9uc2UsXG4gICAgQnVuZGxlXG59IGZyb20gJy4vdHlwZXMuanMnXG5cbmludGVyZmFjZSBCdW5kbGVJbmZvcm1hdGlvbiB7XG4gICAgY2hyb21lZHJpdmVyOiBzdHJpbmdcbiAgICB2c2NvZGU6IHN0cmluZ1xufVxuaW50ZXJmYWNlIE1hbmlmZXN0IHtcbiAgICByZWdpc3RyYXRpb25zOiBSZWdpc3RyYXRpb25bXVxufVxuaW50ZXJmYWNlIFJlZ2lzdHJhdGlvbiB7XG4gICAgdmVyc2lvbjogc3RyaW5nXG4gICAgY29tcG9uZW50OiB7XG4gICAgICAgIGdpdDoge1xuICAgICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgIH1cbiAgICB9XG59XG50eXBlIFZlcnNpb25zID0geyBbZGVzaXJlZFZlcnNpb246IHN0cmluZ106IEJ1bmRsZUluZm9ybWF0aW9uIHwgdW5kZWZpbmVkIH1cblxuLy8gc2V0IHVwIHByb3h5IGlmIGVudmlyb25tZW50IHZhcmlhYmxlIEhUVFBTX1BST1hZIG9yIGh0dHBzX3Byb3h5IGlzIHNldFxubGV0IGRvd25sb2FkQWdlbnRDb25maWd1cmF0aW9uOiBQYXJ0aWFsPERvd25sb2FkT3B0aW9ucz4gfCB1bmRlZmluZWRcbmNvbnN0IGh0dHBzUHJveHkgPSBwcm9jZXNzLmVudi5IVFRQU19QUk9YWSB8fCBwcm9jZXNzLmVudi5odHRwc19wcm94eSB8fCBwcm9jZXNzLmVudi5ucG1fY29uZmlnX3Byb3h5XG5pZiAoaHR0cHNQcm94eSkge1xuICAgIGNvbnN0IHByb3h5VXJsID0gbmV3IFVSTChodHRwc1Byb3h5KVxuICAgIGNvbnN0IHRva2VuID0gcHJveHlVcmwudXNlcm5hbWUgJiYgcHJveHlVcmwucGFzc3dvcmRcbiAgICAgICAgPyBgQmFzaWMgJHtidG9hKGAke3Byb3h5VXJsLnVzZXJuYW1lfToke3Byb3h5VXJsLnBhc3N3b3JkfWApfWBcbiAgICAgICAgOiB1bmRlZmluZWRcblxuICAgIHNldEdsb2JhbERpc3BhdGNoZXIobmV3IFByb3h5QWdlbnQoeyB1cmk6IHByb3h5VXJsLnByb3RvY29sICsgcHJveHlVcmwuaG9zdCwgdG9rZW4gfSkpXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBkb3dubG9hZEFnZW50Q29uZmlndXJhdGlvbiBpcyBub3QgcGFydCBvZiB0aGUgb2ZmaWNpYWwgQVBJXG4gICAgZG93bmxvYWRBZ2VudENvbmZpZ3VyYXRpb24gPSB7IGFnZW50OiBuZXcgSHR0cHNQcm94eUFnZW50KHsgcHJveHk6IHByb3h5VXJsIH0pIH1cbn1cbi8vIHVzZSBIVFRQU19QUk9YWSBvciBodHRwc19wcm94eSBmb3IgQHZzY29kZS90ZXN0LWVsZWN0cm9uIGlmIG5vdCBhbHJlYWR5IHNldFxuaWYgKGh0dHBzUHJveHkgIT09IHByb2Nlc3MuZW52Lm5wbV9jb25maWdfcHJveHkpIHtcbiAgICBwcm9jZXNzLmVudi5ucG1fY29uZmlnX3Byb3h5ID0gaHR0cHNQcm94eVxufVxuXG5jb25zdCBWRVJTSU9OU19UWFQgPSAndmVyc2lvbnMudHh0J1xuY29uc3QgbG9nID0gbG9nZ2VyKCd3ZGlvLXZzY29kZS1zZXJ2aWNlL2xhdW5jaGVyJylcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZTQ29kZVNlcnZpY2VMYXVuY2hlciB7XG4gICAgcHJpdmF0ZSBfY2FjaGVQYXRoOiBzdHJpbmdcbiAgICBwcml2YXRlIF92c2NvZGVTZXJ2ZXJQb3J0PzogbnVtYmVyXG5cbiAgICBjb25zdHJ1Y3RvciAocHJpdmF0ZSBfb3B0aW9uczogU2VydmljZU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVQYXRoID0gdGhpcy5fb3B0aW9ucy5jYWNoZVBhdGggfHwgREVGQVVMVF9DQUNIRV9QQVRIXG4gICAgfVxuXG4gICAgYXN5bmMgb25QcmVwYXJlIChfOiBuZXZlciwgY2FwYWJpbGl0aWVzOiBDYXBhYmlsaXRpZXMuUmVtb3RlQ2FwYWJpbGl0aWVzKSB7XG4gICAgICAgIGNvbnN0IGNhcHM6IFZTQ29kZUNhcGFiaWxpdGllc1tdID0gQXJyYXkuaXNBcnJheShjYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICA/IGNhcGFiaWxpdGllcy5tYXAoKGMpID0+ICgoYyBhcyBDYXBhYmlsaXRpZXMuVzNDQ2FwYWJpbGl0aWVzKS5hbHdheXNNYXRjaCB8fCBjKSBhcyBWU0NvZGVDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICA6IE9iamVjdC52YWx1ZXMoY2FwYWJpbGl0aWVzKS5tYXAoKGMpID0+IGMuY2FwYWJpbGl0aWVzIGFzIFZTQ29kZUNhcGFiaWxpdGllcylcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBWUyBDb2RlIGJ1bmRsZSBmb3IgdGhlIGdpdmVuIHZlcnNpb25cbiAgICAgICAgICogYW5kIGNvbnRpbnVlIHdpdGhvdXQgZG93bmxvYWQgaWYgcG9zc2libGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHZlcnNpb25zRmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5fY2FjaGVQYXRoLCBWRVJTSU9OU19UWFQpXG4gICAgICAgIGNvbnN0IHZlcnNpb25zRmlsZUV4aXN0ID0gYXdhaXQgZmlsZUV4aXN0KHZlcnNpb25zRmlsZVBhdGgpXG5cbiAgICAgICAgZm9yIChjb25zdCBjYXAgb2YgY2Fwcykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBza2lwIHNldHVwIGlmIHVzZXIgaXMgbm90IHVzaW5nIFZTQ29kZSBhcyBjYXBhYmlsaXR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FwLmJyb3dzZXJOYW1lICE9PSAnc3RyaW5nJyB8fCAhY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0udmVyc2lvbiB8fCBjYXAuYnJvd3NlclZlcnNpb24gfHwgREVGQVVMVF9DSEFOTkVMXG4gICAgICAgICAgICBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXS52ZXJzaW9uID0gdmVyc2lvblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHNldHVwIFZTQ29kZSBEZXNrdG9wXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChjYXAuYnJvd3Nlck5hbWUgPT09ICd2c2NvZGUnKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBWU0NvZGVEZXNrdG9wKHZlcnNpb25zRmlsZUV4aXN0LCB2ZXJzaW9uc0ZpbGVQYXRoLCB2ZXJzaW9uLCBjYXApXG4gICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzZXR1cCBWU0NvZGUgV2ViXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVlNDb2RlV2ViKHZlcnNpb24sIGNhcClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB1cCBWU0NvZGUgZm9yIHdlYiB0ZXN0aW5nXG4gICAgICogQHBhcmFtIHZlcnNpb25zRmlsZUV4aXN0IHRydWUgaWYgd2UgYWxyZWFkeSBoYXZlIGluZm9ybWF0aW9uIHN0b3JlZCBhYm91dCBjYWNoZWQgVlNDb2RlIGJ1bmRsZXNcbiAgICAgKiBAcGFyYW0gdmVyc2lvbnNGaWxlUGF0aCBzdHJpbmcgd2l0aCBwYXRoIHRvIGNhY2hlZCBkaXJlY3RvcnlcbiAgICAgKiBAcGFyYW0gY2FwIGNhcGFiaWxpdGllcyB1c2VkIGZvciB0aGlzIHRlc3QgcnVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfc2V0dXBWU0NvZGVXZWIgKFxuICAgICAgICB2ZXJzaW9uOiBzdHJpbmcsXG4gICAgICAgIGNhcDogVlNDb2RlQ2FwYWJpbGl0aWVzXG4gICAgKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBubyBuZWVkIHRvIGRvIGFueSB3b3JrIGlmIHdlIGFscmVhZHkgc3RhcnRlZCB0aGUgc2VydmVyXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5fdnNjb2RlU2VydmVyUG9ydCB8fCAhY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0pIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZVN0YW5kYWxvbmUgPSBhd2FpdCB0aGlzLl9mZXRjaFZTQ29kZVdlYlN0YW5kYWxvbmUodmVyc2lvbilcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBhd2FpdCBzdGFydFNlcnZlcih2c2NvZGVTdGFuZGFsb25lLCBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXSlcbiAgICAgICAgICAgIGNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldLnNlcnZlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLi4uKGNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldLnNlcnZlck9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZTogREVGQVVMVF9WU0NPREVfV0VCX0hPU1ROQU1FXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcG9ydFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNldmVyZVNlcnZpY2VFcnJvcihgQ291bGRuJ3Qgc3RhcnQgc2VydmVyIGZvciBWU0NvZGUgV2ViOiAke2Vyci5tZXNzYWdlfWApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdXAgVlNDb2RlIGZvciBkZXNrdG9wIHRlc3RpbmdcbiAgICAgKiBAcGFyYW0gdmVyc2lvbnNGaWxlRXhpc3QgdHJ1ZSBpZiB3ZSBhbHJlYWR5IGhhdmUgaW5mb3JtYXRpb24gc3RvcmVkIGFib3V0IGNhY2hlZCBWU0NvZGUgYnVuZGxlc1xuICAgICAqIEBwYXJhbSB2ZXJzaW9uc0ZpbGVQYXRoIHN0cmluZyB3aXRoIHBhdGggdG8gY2FjaGVkIGRpcmVjdG9yeVxuICAgICAqIEBwYXJhbSBjYXAgY2FwYWJpbGl0aWVzIHVzZWQgZm9yIHRoaXMgdGVzdCBydW5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIF9zZXR1cFZTQ29kZURlc2t0b3AgKFxuICAgICAgICB2ZXJzaW9uc0ZpbGVFeGlzdDogYm9vbGVhbixcbiAgICAgICAgdmVyc2lvbnNGaWxlUGF0aDogc3RyaW5nLFxuICAgICAgICB2ZXJzaW9uOiBzdHJpbmcsXG4gICAgICAgIGNhcDogVlNDb2RlQ2FwYWJpbGl0aWVzXG4gICAgKSB7XG4gICAgICAgIGlmICghY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8ga2V5IFwiJHtWU0NPREVfQ0FQQUJJTElUWV9LRVl9XCIgZm91bmQgaW4gY2Fwc2ApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmVyc2lvbnNGaWxlRXhpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKChhd2FpdCBmcy5yZWFkRmlsZSh2ZXJzaW9uc0ZpbGVQYXRoLCAndXRmLTgnKSkudG9TdHJpbmcoKSkgYXMgVmVyc2lvbnNcblxuICAgICAgICAgICAgY29uc3QgdnNjb2RlVmVyc2lvbiA9IGNvbnRlbnRbdmVyc2lvbl0/LnZzY29kZVxuICAgICAgICAgICAgY29uc3QgY2hyb21lZHJpdmVyVmVyc2lvbiA9IGNvbnRlbnRbdmVyc2lvbl0/LmNocm9tZWRyaXZlclxuICAgICAgICAgICAgY29uc3QgdnNjb2RlUGF0aCA9IGNhcFtWU0NPREVfQ0FQQUJJTElUWV9LRVldPy5iaW5hcnlcbiAgICAgICAgICAgICAgICB8fCBwYXRoLmpvaW4odGhpcy5fY2FjaGVQYXRoLCBgdnNjb2RlLSR7cHJvY2Vzcy5wbGF0Zm9ybX0tJHtwcm9jZXNzLmFyY2h9LSR7dnNjb2RlVmVyc2lvbn1gKVxuXG4gICAgICAgICAgICBpZiAodnNjb2RlVmVyc2lvbiAmJiBjaHJvbWVkcml2ZXJWZXJzaW9uICYmIGF3YWl0IGZpbGVFeGlzdCh2c2NvZGVQYXRoKSkge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFxuICAgICAgICAgICAgICAgICAgICBgU2tpcHBpbmcgZG93bmxvYWQsIGJ1bmRsZSBmb3IgVlNDb2RlIHYke3ZzY29kZVZlcnNpb259IGFscmVhZHkgZXhpc3RzYFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBjYXAuYnJvd3NlclZlcnNpb24gPSBjaHJvbWVkcml2ZXJWZXJzaW9uXG4gICAgICAgICAgICAgICAgY2FwW1ZTQ09ERV9DQVBBQklMSVRZX0tFWV0uYmluYXJ5IHx8PSBhd2FpdCB0aGlzLl9kb3dubG9hZFZTQ29kZSh2c2NvZGVWZXJzaW9uKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdnNjb2RlVmVyc2lvbiA9IGF3YWl0IHRoaXMuX2ZldGNoVlNDb2RlVmVyc2lvbih2ZXJzaW9uKVxuICAgICAgICBjb25zdCBjaHJvbWVkcml2ZXJWZXJzaW9uID0gYXdhaXQgdGhpcy5fZmV0Y2hDaHJvbWVkcml2ZXJWZXJzaW9uKHZzY29kZVZlcnNpb24pXG5cbiAgICAgICAgY2FwLmJyb3dzZXJWZXJzaW9uID0gY2hyb21lZHJpdmVyVmVyc2lvblxuICAgICAgICBjYXBbVlNDT0RFX0NBUEFCSUxJVFlfS0VZXS5iaW5hcnkgfHw9IGF3YWl0IHRoaXMuX2Rvd25sb2FkVlNDb2RlKHZzY29kZVZlcnNpb24pXG4gICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVZlcnNpb25zVHh0KHZlcnNpb24sIHZzY29kZVZlcnNpb24sIGNocm9tZWRyaXZlclZlcnNpb24sIHZlcnNpb25zRmlsZUV4aXN0KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIFZTQ29kZSBidW5kbGVcbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBWU0NvZGUgdmVyc2lvblxuICAgICAqIEByZXR1cm5zIHBhdGggdG8gZG93bmxvYWRlZCBWU0NvZGUgYnVuZGxlXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfZG93bmxvYWRWU0NvZGUgKHZlcnNpb246IHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9nLmluZm8oYERvd25sb2FkIFZTQ29kZSBiaW5hcnkgKCR7dmVyc2lvbn0pYClcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBkb3dubG9hZCh7XG4gICAgICAgICAgICAgICAgY2FjaGVQYXRoOiB0aGlzLl9jYWNoZVBhdGgsXG4gICAgICAgICAgICAgICAgdmVyc2lvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXZlcmVTZXJ2aWNlRXJyb3IoYENvdWxkbid0IHNldCB1cCBWU0NvZGU6ICR7ZXJyLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBWU0NvZGUgdmVyc2lvbiBiYXNlZCBvbiBkZXNpcmVkIGNoYW5uZWwgb3IgdmFsaWRhdGUgdmVyc2lvbiBpZiBwcm92aWRlZFxuICAgICAqIEBwYXJhbSBkZXNpcmVkUmVsZWFzZUNoYW5uZWwgZWl0aGVyIHJlbGVhc2UgY2hhbm5lbCAoZS5nLiBcInN0YWJsZVwiIG9yIFwiaW5zaWRlcnNcIilcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGEgY29uY3JldGUgdmVyc2lvbiBlLmcuIDEuNjYuMFxuICAgICAqIEByZXR1cm5zIFwibWFpblwiIGlmIGBkZXNpcmVkUmVsZWFzZUNoYW5uZWxgIGlzIFwiaW5zaWRlcnNcIiBvdGhlcndpc2UgYSBjb25jcmV0ZSBWU0NvZGUgdmVyc2lvblxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgX2ZldGNoVlNDb2RlVmVyc2lvbiAoZGVzaXJlZFJlbGVhc2VDaGFubmVsPzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChkZXNpcmVkUmVsZWFzZUNoYW5uZWwgPT09ICdpbnNpZGVycycpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWFpbidcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2cuaW5mbyhgRmV0Y2ggcmVsZWFzZXMgZnJvbSAke1ZTQ09ERV9SRUxFQVNFU31gKVxuICAgICAgICAgICAgY29uc3QgeyBib2R5OiB2ZXJzaW9ucyB9ID0gYXdhaXQgcmVxdWVzdChWU0NPREVfUkVMRUFTRVMsIHt9KVxuICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlVmVyc2lvbnM6IHN0cmluZ1tdID0gYXdhaXQgdmVyc2lvbnMuanNvbigpIGFzIHN0cmluZ1tdXG5cbiAgICAgICAgICAgIGlmIChkZXNpcmVkUmVsZWFzZUNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiB2YWxpZGF0ZSBwcm92aWRlZCBWU0NvZGUgdmVyc2lvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rlc2lyZWRSZWxlYXNlQ2hhbm5lbCA9IGRlc2lyZWRSZWxlYXNlQ2hhbm5lbCA9PT0gJ3N0YWJsZSdcbiAgICAgICAgICAgICAgICAgICAgPyBhdmFpbGFibGVWZXJzaW9uc1swXVxuICAgICAgICAgICAgICAgICAgICA6IGRlc2lyZWRSZWxlYXNlQ2hhbm5lbFxuICAgICAgICAgICAgICAgIGlmICghYXZhaWxhYmxlVmVyc2lvbnMuaW5jbHVkZXMobmV3RGVzaXJlZFJlbGVhc2VDaGFubmVsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgRGVzaXJlZCB2ZXJzaW9uIFwiJHtuZXdEZXNpcmVkUmVsZWFzZUNoYW5uZWx9XCIgaXMgbm90IGV4aXN0ZW50LCBhdmFpbGFibGUgdmVyc2lvbnM6YFxuICAgICAgICAgICAgICAgICAgICAgICAgKyBgJHthdmFpbGFibGVWZXJzaW9ucy5zbGljZSgwLCA1KS5qb2luKCcsICcpfS4uLiwgc2VlICR7VlNDT0RFX1JFTEVBU0VTfWBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdEZXNpcmVkUmVsZWFzZUNoYW5uZWxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVZlcnNpb25zWzBdXG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2V2ZXJlU2VydmljZUVycm9yKGBDb3VsZG4ndCBmZXRjaCBsYXRlc3QgVlNDb2RlOiAke2Vyci5tZXNzYWdlfWApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHJlcXVpcmVkIENocm9tZWRyaXZlciB2ZXJzaW9uIGZvciBnaXZlbiBWU0NvZGUgdmVyc2lvblxuICAgICAqIEBwYXJhbSB2c2NvZGVWZXJzaW9uIGJyYW5jaCBvciB0YWcgdmVyc2lvbiBvZiBWU0NvZGUgcmVwb3NpdG9yeVxuICAgICAqIEByZXR1cm5zIHJlcXVpcmVkIENocm9tZWRyaXZlciB2ZXJzaW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBfZmV0Y2hDaHJvbWVkcml2ZXJWZXJzaW9uICh2c2NvZGVWZXJzaW9uOiBzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYm9keSB9ID0gYXdhaXQgcmVxdWVzdChmb3JtYXQoVlNDT0RFX01BTklGRVNUX1VSTCwgdnNjb2RlVmVyc2lvbiksIHt9KVxuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBhd2FpdCBib2R5Lmpzb24oKSBhcyBNYW5pZmVzdFxuICAgICAgICAgICAgY29uc3QgY2hyb21pdW0gPSBtYW5pZmVzdC5yZWdpc3RyYXRpb25zLmZpbmQoKHI6IGFueSkgPT4gci5jb21wb25lbnQuZ2l0Lm5hbWUgPT09ICdjaHJvbWl1bScpXG5cbiAgICAgICAgICAgIGlmICghY2hyb21pdW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgZmluZCBjaHJvbWl1bSB2ZXJzaW9uIGluIG1hbmlmZXN0IHJlc3BvbnNlJylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNocm9taXVtLnZlcnNpb24uc3BsaXQoJy4nKVswXVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNldmVyZVNlcnZpY2VFcnJvcihgQ291bGRuJ3QgZmV0Y2ggQ2hyb21lZHJpdmVyIHZlcnNpb246ICR7ZXJyLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgVlNDb2RlIFdlYiBmaWxlc1xuICAgICAqIFRvRG8oQ2hyaXN0aWFuKTogYWxsb3cgdG8gZGVmaW5lIGEgbG9jYWwgVlNDb2RlIGRldmVsb3BtZW50IHBhdGhcbiAgICAgKiAgICAgICAgICAgICAgICAgIHRvIGJlIGFibGUgdG8gc2tpcCB0aGlzIHBhcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIF9mZXRjaFZTQ29kZVdlYlN0YW5kYWxvbmUgKHZzY29kZVZlcnNpb246IHN0cmluZyk6IFByb21pc2U8QnVuZGxlPiB7XG4gICAgICAgIGlmICh2c2NvZGVWZXJzaW9uICE9PSAnc3RhYmxlJyAmJiB2c2NvZGVWZXJzaW9uICE9PSAnaW5zaWRlcnMnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bm5pbmcgVlNDb2RlIGluIHRoZSBicm93c2VyIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBcInN0YWJsZVwiIGFuZCBcImluc2lkZXJzXCIgdmVyc2lvbicpXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBib2R5IH0gPSBhd2FpdCByZXF1ZXN0KGZvcm1hdChWU0NPREVfV0VCX1NUQU5EQUxPTkUsIHZzY29kZVZlcnNpb24pLCB7fSlcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCBib2R5Lmpzb24oKSBhcyBXZWJTdGFuZGFsb25lUmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlciA9IHBhdGguam9pbih0aGlzLl9jYWNoZVBhdGgsIGB2c2NvZGUtd2ViLSR7dnNjb2RlVmVyc2lvbn0tJHtpbmZvLnZlcnNpb259YClcblxuICAgICAgICAgICAgaWYgKCEoYXdhaXQgZGlyZWN0b3J5RXhpc3RzKGZvbGRlcikpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZG93bmxvYWRCdW5kbGUoaW5mby51cmwsIGZvbGRlciwgeyBleHRyYWN0OiB0cnVlLCBzdHJpcDogMSwgLi4uZG93bmxvYWRBZ2VudENvbmZpZ3VyYXRpb24gfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogZm9sZGVyLCB2c2NvZGVWZXJzaW9uLCB2ZXJzaW9uOiBpbmZvLnZlcnNpb24gfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNldmVyZVNlcnZpY2VFcnJvcihgQ291bGRuJ3Qgc2V0IHVwIFZTQ29kZSBXZWI6ICR7ZXJyLm1lc3NhZ2V9YClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3VwZGF0ZVZlcnNpb25zVHh0IChcbiAgICAgICAgdmVyc2lvbjogc3RyaW5nLFxuICAgICAgICB2c2NvZGVWZXJzaW9uOiBzdHJpbmcsXG4gICAgICAgIGNocm9tZWRyaXZlclZlcnNpb246IHN0cmluZyxcbiAgICAgICAgdmVyc2lvbnNGaWxlRXhpc3Q6IGJvb2xlYW5cbiAgICApIHtcbiAgICAgICAgY29uc3QgbmV3Q29udGVudDogVmVyc2lvbnMgPSB7XG4gICAgICAgICAgICBbdmVyc2lvbl06IHtcbiAgICAgICAgICAgICAgICBjaHJvbWVkcml2ZXI6IGNocm9tZWRyaXZlclZlcnNpb24sXG4gICAgICAgICAgICAgICAgdnNjb2RlOiB2c2NvZGVWZXJzaW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyc2lvbnNUeHRQYXRoID0gcGF0aC5qb2luKHRoaXMuX2NhY2hlUGF0aCwgVkVSU0lPTlNfVFhUKVxuICAgICAgICBpZiAoIXZlcnNpb25zRmlsZUV4aXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnMud3JpdGVGaWxlKFxuICAgICAgICAgICAgICAgIHZlcnNpb25zVHh0UGF0aCxcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXdDb250ZW50LCBudWxsLCA0KSxcbiAgICAgICAgICAgICAgICAndXRmLTgnXG4gICAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZSgoYXdhaXQgZnMucmVhZEZpbGUodmVyc2lvbnNUeHRQYXRoLCAndXRmLTgnKSkudG9TdHJpbmcoKSlcbiAgICAgICAgcmV0dXJuIGZzLndyaXRlRmlsZShcbiAgICAgICAgICAgIHZlcnNpb25zVHh0UGF0aCxcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsgLi4uY29udGVudCwgLi4ubmV3Q29udGVudCB9LCBudWxsLCA0KSxcbiAgICAgICAgICAgICd1dGYtOCdcbiAgICAgICAgKVxuICAgIH1cbn1cbiJdfQ==